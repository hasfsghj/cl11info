A[n] < A[n+1] crescator
A[n] > A[n+1] descrescator

metode de sortare:
.selectie
.insertie
.metoda bulelor
.distribuire
.interclasare
.quick sort 
.merge sort 
.heap sort


selectia: metoda de sortare care parcurge secventa de elemente nesortate, determina elementul minim (sau maxim), si il aduce la inceputul secventei.
  - prima metoda neoptimala (face multe schimburi de valori)
        for (i=0; i<=n-2; i++);
         for (j=i+1; j<=n-1; j++);
          if (a[j]<a[i]) swap(a[i], a[j]);
    de exemplu, avem sirul 23, 14, 6, 41, 27, 5.
    parcurge tot sirul si vede ca cel mai mare element e 41. il schimba cu ultimul element cu locul. apoi, parcurge tot sirul -1 unitate (fiindca o
    unitate deja i-am gasit locul; 41) si vede ca 27 e cel mai mare element. deci, schimba penultimul termen cu locul. continua tot asa cu atatea
    iteratii, cate elemente avem in sir.
  - a doua metoda optimala
        int minn, k;
        for (i=0; i<=n-2; i++)
         {min=A[i]; k=i;}
         for (j=i+1; j<=n-1; j++)
          if (A[j]<minn) {minn=A[j]; k=j;}
         if (k!=i) swap (A[i], A[k])
    variabila minn va afla elementul minim de la i+1 pana la n-1, iar k va pastra locul unde se afla elementul minim. daca k!=i, atunci se face
    doar un singur schimb de valori intre swap (A[i], A[k])


insertia: lucreaza cu elemente deja aranjate, si un element din cele nearanjate. el compara si gaseste pozitia si il insereaza
    de exemplu avem tabloul 23, 14, 6, 41, 27, 5, si dupa primul element formeaza un subsir sortat. apoi ne uitam si la al doilea element,
    si il inseram in subsir; de exemplu, aici al doilea element este 14, ce este mai mic ca 23, deci subsirul sortat devine 14, 23. apoi se
    uita la al treilea element si il insereaza la locul lui. 6 e mai mic ca ambele elemente, deci vine la primul loc, si subsirul
    devine 6, 14, 23. si tot asa continua pana ce toate elementele au fost sortate / adaugate in subsir
        for (i=1; i<=n-1; i++)
        {x=A[i]; j=i-1;
        while (j>=0 && x<A[j]) {A[j+1]=A[j]; j--;
        A[j+1]=x; }}


bubble sort:
        for (i=1; i<=n-1; i++)
        for (j=0; j<=n-2; j++)
        if (A[j+1]<A[j]) swap (A[j], A[j+1]);